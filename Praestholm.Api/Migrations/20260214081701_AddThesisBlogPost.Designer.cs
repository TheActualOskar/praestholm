// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Praestholm.Api.Data;

#nullable disable

namespace Praestholm.Api.Migrations
{
    [DbContext(typeof(BlogDbContext))]
    [Migration("20260214081701_AddThesisBlogPost")]
    partial class AddThesisBlogPost
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.24")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("Praestholm.Api.Models.BlogPost", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Author")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("nvarchar(500)");

                    b.Property<bool>("IsPublished")
                        .HasColumnType("bit");

                    b.Property<DateTime?>("PublishedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Slug")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("Tags")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("nvarchar(500)");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("Slug")
                        .IsUnique();

                    b.ToTable("BlogPosts");

                    b.HasData(
                        new
                        {
                            Id = 2,
                            Author = "Oskar Praestholm",
                            Content = "# Building a Portfolio with React and .NET\n\nWhen I decided to build my portfolio site, I wanted it to reflect the technologies I work with daily. That meant combining a modern React frontend with a robust .NET backend — a stack I'm passionate about.\n\n## The Tech Stack\n\n- **Frontend:** React 19, TypeScript, Vite\n- **Backend:** ASP.NET Core 8 (Minimal APIs)\n- **Styling:** Custom CSS with glassmorphism design\n- **Deployment:** Docker\n\n## Architecture Decisions\n\n### Why Minimal APIs?\n\nASP.NET Core's Minimal APIs offer a clean, lightweight approach to building HTTP endpoints. For a portfolio site, we don't need the full ceremony of controllers, so Minimal APIs keep things simple:\n\n```csharp\napp.MapGet(\"/api/projects\", async (ProjectsService service) =>\n{\n    var projects = await service.GetProjectsAsync();\n    return Results.Ok(projects);\n});\n```\n\n### Why Vite?\n\nVite provides an incredibly fast development experience with hot module replacement (HMR). Combined with TypeScript and React, it makes frontend development a joy.\n\n### The GitHub Integration\n\nRather than manually maintaining a list of projects, the site pulls project data directly from GitHub's API. This means the portfolio stays up to date automatically. Projects tagged with a specific topic appear on the site, and featured projects get highlighted.\n\n## Design Philosophy\n\nThe design uses a dark theme with glassmorphism effects — frosted glass cards, subtle gradients, and an animated starfield background. The goal was to create something that feels modern and polished without being distracting.\n\n### Key Design Elements\n\n- **Glass cards** with `backdrop-filter: blur()` and semi-transparent backgrounds\n- **CSS custom properties** for consistent theming\n- **Responsive layout** that works on mobile and desktop\n- **Animated canvas background** with twinkling stars\n\n## Lessons Learned\n\n1. **Keep it simple** — A portfolio should showcase your work, not overwhelm visitors\n2. **Performance matters** — Lazy loading images and caching API responses make a big difference\n3. **Accessibility** — Semantic HTML, focus states, and reduced motion support are essential\n4. **Iterate** — The first version doesn't have to be perfect; ship and improve\n\nBuilding your own portfolio is one of the best ways to learn and demonstrate your skills. It's a project you own completely, and you can make it exactly what you want.",
                            CreatedAt = new DateTime(2025, 1, 20, 12, 0, 0, 0, DateTimeKind.Utc),
                            Description = "A look behind the scenes at how this portfolio site was built using React 19, TypeScript, and ASP.NET Core 8 — and the decisions that shaped it.",
                            IsPublished = true,
                            PublishedAt = new DateTime(2025, 1, 20, 12, 0, 0, 0, DateTimeKind.Utc),
                            Slug = "building-a-portfolio-with-react-and-dotnet",
                            Tags = "React,.NET,TypeScript,Portfolio,Web Development",
                            Title = "Building a Portfolio with React and .NET",
                            UpdatedAt = new DateTime(2025, 1, 20, 12, 0, 0, 0, DateTimeKind.Utc)
                        },
                        new
                        {
                            Id = 4,
                            Author = "Oskar Praestholm",
                            Content = "# My Master's Thesis: Query-Based Subscription for IoT Data Streams\n\nIn June 2025 I completed my master's thesis in Software Engineering at the University of Southern Denmark (SDU), supervised by Aslak Johansen. The thesis investigates whether a **query-based subscription (QBS) model** can provide a more scalable and flexible alternative to the traditional query-loop approach for managing IoT data streams.\n\n## The Problem\n\nIn dynamic IoT environments, new devices and data streams can appear at any time. Traditional systems rely on a **query-loop** approach where clients continuously poll for new data sources. Every time a new sensor is added, the query must be updated to include it. This leads to inefficiencies, increased development complexity, and a constant need for manual intervention as the system grows.\n\nThe thesis asks: *what if the system could automatically push relevant data streams to clients as they appear, based on declarative subscriptions?*\n\n## The Approach\n\nThe proposed solution flips the model from **pull to push**. Instead of clients repeatedly querying for new sources, they subscribe once using metadata-driven queries, and the system automatically routes matching data streams as they become available.\n\n### Key Technologies\n\n- **MQTT** for real-time data exchange between the broker and clients\n- **Neo4j** graph database for storing and querying IoT metadata (devices, rooms, sensor types, and their relationships)\n- **Akka.NET** actor framework for building a modular, concurrent custom broker\n- **Cypher** queries for defining flexible, graph-based subscriptions\n\n## System Architecture\n\nThe system is built around a **custom MQTT broker** structured using an actor-based model. Each actor handles a specific responsibility:\n\n- **PackageListener** receives incoming MQTT packets and routes them to the appropriate handler\n- **PublishHandler** extracts payloads and forwards them to the MessageRouter\n- **SubscribeHandler** evaluates whether a subscription targets a static topic or a dynamic virtual topic\n- **VirtualTopicValidator** manages metadata-aware subscriptions by matching new data streams against precomputed label sets\n- **MessageRouter** delivers data to all matching subscribers\n- **EventNotifier** pushes real-time updates via WebSocket\n\n### The SmartFilter Mechanism\n\nA core innovation is the **SmartFilter**. Instead of evaluating the full Cypher query every time new data arrives, the system runs the query once at subscription time and extracts a set of *expected labels* (e.g., sensor type = \"temperature\", room = \"Room-A\"). New data streams are then matched against these labels at runtime, avoiding repeated database queries.\n\nThis shifts the cost from runtime to subscription time, making message routing fast and lightweight while still supporting expressive metadata-based filtering.\n\n### Graph-Based Metadata Model\n\nThe metadata is stored as a **labeled property graph** in Neo4j. IoT devices are nodes linked to their data streams, rooms, buildings, and sensor types. This allows users to write a single Cypher query like *\"give me all temperature streams in Building 42\"* and have the system automatically create a virtual topic that follows matching data streams, including ones added in the future.\n\n## Evaluation and Results\n\nThe QBS model was compared against the traditional query-loop (QL) approach across latency, memory usage, and CPU behavior with 10 to 4,000 concurrent queries.\n\n**Key findings:**\n\n- **Stable latency:** QBS averaged ~2 seconds end-to-end latency, consistent across all workloads, with no added overhead once SmartFilters were registered\n- **CPU behavior:** QBS showed event-driven CPU load variance, while QL maintained steady polling cycles with uniform resource consumption\n- **Memory trade-off:** QBS uses more memory upfront for SmartFilter construction (~167-171 MB) but stabilizes, while QL starts lighter (~2.5 MB) but grows less predictably with active queries\n- **Best suited for:** Systems with long-lived subscriptions and high message throughput per topic\n\nWhile the results were not conclusive enough to declare QBS definitively superior, the system demonstrates **technical feasibility** and shows clear architectural benefits for certain workload profiles.\n\n## Lessons Learned\n\n1. **Protocol compliance matters** — Early reliance on the permissive Mosquitto test client masked missing MQTT features (like keep-alive handling) that only surfaced with stricter clients later\n2. **Actor boundaries need discipline** — The modular actor design provided clarity, but components like the MessageRouter accumulated too many responsibilities under load\n3. **SmartFilters trade flexibility for performance** — The approach works well when subscriptions are stable, but struggles when they change frequently\n4. **Custom brokers are powerful but demanding** — Full control over metadata, queries, and subscriptions came at the cost of development complexity and ecosystem maturity\n\n## Looking Forward\n\nFuture work includes revisiting the broker architecture to reduce latency, adding proper MQTT keep-alive support, introducing load balancing, and conducting evaluations in isolated test environments at larger scale.\n\nThe thesis establishes a foundation for **adaptive, declarative IoT data integration** — a step toward systems where developers describe what data they need, and the infrastructure handles the rest.",
                            CreatedAt = new DateTime(2025, 2, 14, 12, 0, 0, 0, DateTimeKind.Utc),
                            Description = "A summary of my master's thesis on designing a query-based subscription model for managing IoT data streams, featuring a custom MQTT broker, Neo4j metadata graph, and SmartFilter mechanism.",
                            IsPublished = true,
                            PublishedAt = new DateTime(2025, 2, 14, 12, 0, 0, 0, DateTimeKind.Utc),
                            Slug = "masters-thesis-query-based-subscription-iot",
                            Tags = "IoT,MQTT,Thesis,Software Engineering,.NET",
                            Title = "My Master's Thesis: Query-Based Subscription for IoT Data Streams",
                            UpdatedAt = new DateTime(2025, 2, 14, 12, 0, 0, 0, DateTimeKind.Utc)
                        },
                        new
                        {
                            Id = 3,
                            Author = "Oskar Praestholm",
                            Content = "# Understanding REST API Design\n\nDesigning a good REST API is about more than just making endpoints that return JSON. A well-designed API is intuitive, consistent, and easy to use. Here are the core principles I follow.\n\n## Resource-Oriented Design\n\nREST APIs should be organized around **resources** — the nouns in your system. Use plural nouns for collections:\n\n```\nGET    /api/users          → List all users\nGET    /api/users/42       → Get user 42\nPOST   /api/users          → Create a user\nPUT    /api/users/42       → Update user 42\nDELETE /api/users/42       → Delete user 42\n```\n\nAvoid verbs in URLs. The HTTP method already tells you the action.\n\n## HTTP Methods\n\nUse HTTP methods correctly:\n\n| Method | Purpose | Idempotent? |\n|--------|---------|-------------|\n| GET | Read a resource | Yes |\n| POST | Create a resource | No |\n| PUT | Update/replace a resource | Yes |\n| PATCH | Partial update | No |\n| DELETE | Remove a resource | Yes |\n\n## Status Codes\n\nUse appropriate HTTP status codes:\n\n- **200 OK** — Successful GET, PUT, PATCH\n- **201 Created** — Successful POST (include Location header)\n- **204 No Content** — Successful DELETE\n- **400 Bad Request** — Invalid input\n- **404 Not Found** — Resource doesn't exist\n- **409 Conflict** — Duplicate or conflicting state\n- **500 Internal Server Error** — Something went wrong on the server\n\n## Pagination\n\nFor collections that could be large, always paginate:\n\n```\nGET /api/posts?page=2&pageSize=10\n```\n\nReturn pagination metadata in the response:\n\n```json\n{\n  \"data\": [...],\n  \"page\": 2,\n  \"pageSize\": 10,\n  \"totalCount\": 47,\n  \"totalPages\": 5\n}\n```\n\n## Filtering and Sorting\n\nSupport filtering via query parameters:\n\n```\nGET /api/posts?author=oskar&tag=docker\nGET /api/posts?sort=createdAt&order=desc\n```\n\n## Error Responses\n\nUse a consistent error format:\n\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Title is required\",\n    \"details\": [\n      { \"field\": \"title\", \"message\": \"Must not be empty\" }\n    ]\n  }\n}\n```\n\n## Versioning\n\nPlan for API evolution. Common strategies:\n\n- **URL versioning:** `/api/v1/users` (simplest)\n- **Header versioning:** `Accept: application/vnd.api.v1+json`\n- **Query parameter:** `/api/users?version=1`\n\nURL versioning is the most common and easiest to understand.\n\n## Summary\n\nA great REST API is:\n\n- **Consistent** — Same patterns everywhere\n- **Predictable** — Follows HTTP conventions\n- **Well-documented** — Developers can figure it out quickly\n- **Paginated** — Handles large datasets gracefully\n\nFollowing these principles makes your API a pleasure to work with — for your team and for external consumers.",
                            CreatedAt = new DateTime(2025, 1, 25, 12, 0, 0, 0, DateTimeKind.Utc),
                            Description = "Core principles of designing clean, consistent REST APIs — from resource naming and HTTP methods to status codes and pagination.",
                            IsPublished = true,
                            PublishedAt = new DateTime(2025, 1, 25, 12, 0, 0, 0, DateTimeKind.Utc),
                            Slug = "understanding-rest-api-design",
                            Tags = "API,REST,Backend,Architecture,Best Practices",
                            Title = "Understanding REST API Design",
                            UpdatedAt = new DateTime(2025, 1, 25, 12, 0, 0, 0, DateTimeKind.Utc)
                        });
                });
#pragma warning restore 612, 618
        }
    }
}
