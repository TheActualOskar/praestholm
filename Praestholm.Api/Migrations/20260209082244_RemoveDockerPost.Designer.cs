// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Praestholm.Api.Data;

#nullable disable

namespace Praestholm.Api.Migrations
{
    [DbContext(typeof(BlogDbContext))]
    [Migration("20260209082244_RemoveDockerPost")]
    partial class RemoveDockerPost
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.23")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("Praestholm.Api.Models.BlogPost", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Author")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("nvarchar(500)");

                    b.Property<bool>("IsPublished")
                        .HasColumnType("bit");

                    b.Property<DateTime?>("PublishedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Slug")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("Tags")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("nvarchar(500)");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("Slug")
                        .IsUnique();

                    b.ToTable("BlogPosts");

                    b.HasData(
                        new
                        {
                            Id = 2,
                            Author = "Oskar Praestholm",
                            Content = "# Building a Portfolio with React and .NET\n\nWhen I decided to build my portfolio site, I wanted it to reflect the technologies I work with daily. That meant combining a modern React frontend with a robust .NET backend — a stack I'm passionate about.\n\n## The Tech Stack\n\n- **Frontend:** React 19, TypeScript, Vite\n- **Backend:** ASP.NET Core 8 (Minimal APIs)\n- **Styling:** Custom CSS with glassmorphism design\n- **Deployment:** Docker\n\n## Architecture Decisions\n\n### Why Minimal APIs?\n\nASP.NET Core's Minimal APIs offer a clean, lightweight approach to building HTTP endpoints. For a portfolio site, we don't need the full ceremony of controllers, so Minimal APIs keep things simple:\n\n```csharp\napp.MapGet(\"/api/projects\", async (ProjectsService service) =>\n{\n    var projects = await service.GetProjectsAsync();\n    return Results.Ok(projects);\n});\n```\n\n### Why Vite?\n\nVite provides an incredibly fast development experience with hot module replacement (HMR). Combined with TypeScript and React, it makes frontend development a joy.\n\n### The GitHub Integration\n\nRather than manually maintaining a list of projects, the site pulls project data directly from GitHub's API. This means the portfolio stays up to date automatically. Projects tagged with a specific topic appear on the site, and featured projects get highlighted.\n\n## Design Philosophy\n\nThe design uses a dark theme with glassmorphism effects — frosted glass cards, subtle gradients, and an animated starfield background. The goal was to create something that feels modern and polished without being distracting.\n\n### Key Design Elements\n\n- **Glass cards** with `backdrop-filter: blur()` and semi-transparent backgrounds\n- **CSS custom properties** for consistent theming\n- **Responsive layout** that works on mobile and desktop\n- **Animated canvas background** with twinkling stars\n\n## Lessons Learned\n\n1. **Keep it simple** — A portfolio should showcase your work, not overwhelm visitors\n2. **Performance matters** — Lazy loading images and caching API responses make a big difference\n3. **Accessibility** — Semantic HTML, focus states, and reduced motion support are essential\n4. **Iterate** — The first version doesn't have to be perfect; ship and improve\n\nBuilding your own portfolio is one of the best ways to learn and demonstrate your skills. It's a project you own completely, and you can make it exactly what you want.",
                            CreatedAt = new DateTime(2025, 1, 20, 12, 0, 0, 0, DateTimeKind.Utc),
                            Description = "A look behind the scenes at how this portfolio site was built using React 19, TypeScript, and ASP.NET Core 8 — and the decisions that shaped it.",
                            IsPublished = true,
                            PublishedAt = new DateTime(2025, 1, 20, 12, 0, 0, 0, DateTimeKind.Utc),
                            Slug = "building-a-portfolio-with-react-and-dotnet",
                            Tags = "React,.NET,TypeScript,Portfolio,Web Development",
                            Title = "Building a Portfolio with React and .NET",
                            UpdatedAt = new DateTime(2025, 1, 20, 12, 0, 0, 0, DateTimeKind.Utc)
                        },
                        new
                        {
                            Id = 3,
                            Author = "Oskar Praestholm",
                            Content = "# Understanding REST API Design\n\nDesigning a good REST API is about more than just making endpoints that return JSON. A well-designed API is intuitive, consistent, and easy to use. Here are the core principles I follow.\n\n## Resource-Oriented Design\n\nREST APIs should be organized around **resources** — the nouns in your system. Use plural nouns for collections:\n\n```\nGET    /api/users          → List all users\nGET    /api/users/42       → Get user 42\nPOST   /api/users          → Create a user\nPUT    /api/users/42       → Update user 42\nDELETE /api/users/42       → Delete user 42\n```\n\nAvoid verbs in URLs. The HTTP method already tells you the action.\n\n## HTTP Methods\n\nUse HTTP methods correctly:\n\n| Method | Purpose | Idempotent? |\n|--------|---------|-------------|\n| GET | Read a resource | Yes |\n| POST | Create a resource | No |\n| PUT | Update/replace a resource | Yes |\n| PATCH | Partial update | No |\n| DELETE | Remove a resource | Yes |\n\n## Status Codes\n\nUse appropriate HTTP status codes:\n\n- **200 OK** — Successful GET, PUT, PATCH\n- **201 Created** — Successful POST (include Location header)\n- **204 No Content** — Successful DELETE\n- **400 Bad Request** — Invalid input\n- **404 Not Found** — Resource doesn't exist\n- **409 Conflict** — Duplicate or conflicting state\n- **500 Internal Server Error** — Something went wrong on the server\n\n## Pagination\n\nFor collections that could be large, always paginate:\n\n```\nGET /api/posts?page=2&pageSize=10\n```\n\nReturn pagination metadata in the response:\n\n```json\n{\n  \"data\": [...],\n  \"page\": 2,\n  \"pageSize\": 10,\n  \"totalCount\": 47,\n  \"totalPages\": 5\n}\n```\n\n## Filtering and Sorting\n\nSupport filtering via query parameters:\n\n```\nGET /api/posts?author=oskar&tag=docker\nGET /api/posts?sort=createdAt&order=desc\n```\n\n## Error Responses\n\nUse a consistent error format:\n\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Title is required\",\n    \"details\": [\n      { \"field\": \"title\", \"message\": \"Must not be empty\" }\n    ]\n  }\n}\n```\n\n## Versioning\n\nPlan for API evolution. Common strategies:\n\n- **URL versioning:** `/api/v1/users` (simplest)\n- **Header versioning:** `Accept: application/vnd.api.v1+json`\n- **Query parameter:** `/api/users?version=1`\n\nURL versioning is the most common and easiest to understand.\n\n## Summary\n\nA great REST API is:\n\n- **Consistent** — Same patterns everywhere\n- **Predictable** — Follows HTTP conventions\n- **Well-documented** — Developers can figure it out quickly\n- **Paginated** — Handles large datasets gracefully\n\nFollowing these principles makes your API a pleasure to work with — for your team and for external consumers.",
                            CreatedAt = new DateTime(2025, 1, 25, 12, 0, 0, 0, DateTimeKind.Utc),
                            Description = "Core principles of designing clean, consistent REST APIs — from resource naming and HTTP methods to status codes and pagination.",
                            IsPublished = true,
                            PublishedAt = new DateTime(2025, 1, 25, 12, 0, 0, 0, DateTimeKind.Utc),
                            Slug = "understanding-rest-api-design",
                            Tags = "API,REST,Backend,Architecture,Best Practices",
                            Title = "Understanding REST API Design",
                            UpdatedAt = new DateTime(2025, 1, 25, 12, 0, 0, 0, DateTimeKind.Utc)
                        });
                });
#pragma warning restore 612, 618
        }
    }
}
