using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Praestholm.Api.Migrations
{
    /// <inheritdoc />
    public partial class AddThesisBlogPost : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.InsertData(
                table: "BlogPosts",
                columns: new[] { "Id", "Author", "Content", "CreatedAt", "Description", "IsPublished", "PublishedAt", "Slug", "Tags", "Title", "UpdatedAt" },
                values: new object[] { 4, "Oskar Praestholm", "# My Master's Thesis: Query-Based Subscription for IoT Data Streams\n\nIn June 2025 I completed my master's thesis in Software Engineering at the University of Southern Denmark (SDU), supervised by Aslak Johansen. The thesis investigates whether a **query-based subscription (QBS) model** can provide a more scalable and flexible alternative to the traditional query-loop approach for managing IoT data streams.\n\n## The Problem\n\nIn dynamic IoT environments, new devices and data streams can appear at any time. Traditional systems rely on a **query-loop** approach where clients continuously poll for new data sources. Every time a new sensor is added, the query must be updated to include it. This leads to inefficiencies, increased development complexity, and a constant need for manual intervention as the system grows.\n\nThe thesis asks: *what if the system could automatically push relevant data streams to clients as they appear, based on declarative subscriptions?*\n\n## The Approach\n\nThe proposed solution flips the model from **pull to push**. Instead of clients repeatedly querying for new sources, they subscribe once using metadata-driven queries, and the system automatically routes matching data streams as they become available.\n\n### Key Technologies\n\n- **MQTT** for real-time data exchange between the broker and clients\n- **Neo4j** graph database for storing and querying IoT metadata (devices, rooms, sensor types, and their relationships)\n- **Akka.NET** actor framework for building a modular, concurrent custom broker\n- **Cypher** queries for defining flexible, graph-based subscriptions\n\n## System Architecture\n\nThe system is built around a **custom MQTT broker** structured using an actor-based model. Each actor handles a specific responsibility:\n\n- **PackageListener** receives incoming MQTT packets and routes them to the appropriate handler\n- **PublishHandler** extracts payloads and forwards them to the MessageRouter\n- **SubscribeHandler** evaluates whether a subscription targets a static topic or a dynamic virtual topic\n- **VirtualTopicValidator** manages metadata-aware subscriptions by matching new data streams against precomputed label sets\n- **MessageRouter** delivers data to all matching subscribers\n- **EventNotifier** pushes real-time updates via WebSocket\n\n### The SmartFilter Mechanism\n\nA core innovation is the **SmartFilter**. Instead of evaluating the full Cypher query every time new data arrives, the system runs the query once at subscription time and extracts a set of *expected labels* (e.g., sensor type = \"temperature\", room = \"Room-A\"). New data streams are then matched against these labels at runtime, avoiding repeated database queries.\n\nThis shifts the cost from runtime to subscription time, making message routing fast and lightweight while still supporting expressive metadata-based filtering.\n\n### Graph-Based Metadata Model\n\nThe metadata is stored as a **labeled property graph** in Neo4j. IoT devices are nodes linked to their data streams, rooms, buildings, and sensor types. This allows users to write a single Cypher query like *\"give me all temperature streams in Building 42\"* and have the system automatically create a virtual topic that follows matching data streams, including ones added in the future.\n\n## Evaluation and Results\n\nThe QBS model was compared against the traditional query-loop (QL) approach across latency, memory usage, and CPU behavior with 10 to 4,000 concurrent queries.\n\n**Key findings:**\n\n- **Stable latency:** QBS averaged ~2 seconds end-to-end latency, consistent across all workloads, with no added overhead once SmartFilters were registered\n- **CPU behavior:** QBS showed event-driven CPU load variance, while QL maintained steady polling cycles with uniform resource consumption\n- **Memory trade-off:** QBS uses more memory upfront for SmartFilter construction (~167-171 MB) but stabilizes, while QL starts lighter (~2.5 MB) but grows less predictably with active queries\n- **Best suited for:** Systems with long-lived subscriptions and high message throughput per topic\n\nWhile the results were not conclusive enough to declare QBS definitively superior, the system demonstrates **technical feasibility** and shows clear architectural benefits for certain workload profiles.\n\n## Lessons Learned\n\n1. **Protocol compliance matters** — Early reliance on the permissive Mosquitto test client masked missing MQTT features (like keep-alive handling) that only surfaced with stricter clients later\n2. **Actor boundaries need discipline** — The modular actor design provided clarity, but components like the MessageRouter accumulated too many responsibilities under load\n3. **SmartFilters trade flexibility for performance** — The approach works well when subscriptions are stable, but struggles when they change frequently\n4. **Custom brokers are powerful but demanding** — Full control over metadata, queries, and subscriptions came at the cost of development complexity and ecosystem maturity\n\n## Looking Forward\n\nFuture work includes revisiting the broker architecture to reduce latency, adding proper MQTT keep-alive support, introducing load balancing, and conducting evaluations in isolated test environments at larger scale.\n\nThe thesis establishes a foundation for **adaptive, declarative IoT data integration** — a step toward systems where developers describe what data they need, and the infrastructure handles the rest.", new DateTime(2025, 2, 14, 12, 0, 0, 0, DateTimeKind.Utc), "A summary of my master's thesis on designing a query-based subscription model for managing IoT data streams, featuring a custom MQTT broker, Neo4j metadata graph, and SmartFilter mechanism.", true, new DateTime(2025, 2, 14, 12, 0, 0, 0, DateTimeKind.Utc), "masters-thesis-query-based-subscription-iot", "IoT,MQTT,Thesis,Software Engineering,.NET", "My Master's Thesis: Query-Based Subscription for IoT Data Streams", new DateTime(2025, 2, 14, 12, 0, 0, 0, DateTimeKind.Utc) });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DeleteData(
                table: "BlogPosts",
                keyColumn: "Id",
                keyValue: 4);
        }
    }
}
